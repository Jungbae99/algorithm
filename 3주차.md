## 문제 7 삽질

* int는 32비트로 1 << len은 최대 2^31까지 처리할 수 있는데, 289자리가 와서 오류
* 문제 최대 조건을 잘 살펴보자. 비트는 부분집합 최대 주어진 개수 적을 때나 쓰자

~~~java
class Main {
    public static void main(String[] args) throws Exception {
        int[] nums = {-2489365,-993808,7677553,-6236212,4790337,7644796,-17608,-5925223,1001245,-460212,653772,5293761,3423463,7887896,6682993,-7160383,-8961165,-4427439,-292075,-7135767,4083793,-6960662,8142868,-4240394,8025016,-2556360,2350768,-4461693,-4560806,-3584319,-260547,7555881,5425240,-4005238,1884863,-1542675,-7228114,-1569944,1127787,2957411,-1242460,8952147,-4274786,-3547360,-2021990,3996052,-5990652,-2548871,-5738166,2898644,-3621230,-8941983,-2947855,6725035,4132935,2365022,-779089,7301765,7592999,1348187,5460485,-6122562,6040748,4998516,1711224,2502134,-3494412,1734467,-2483280,-5130317,-172673,5886671,-7923584,337280,3523150,7822530,-6359601,3438172,1810201,6740543,-6990467,-8944667,107690,4556956,6905123,6842712,7038959,-1623617,5486272,133419,-3934378,-888166,4176021,7922519,5245309,9130043,8978076,8808437,8416577,4767255,-7278336,-8728641,-9003137,-9503175,5550490,8968777,1768371,7942934,9782721,-5302342,-3076168,3328396,-4620783,-3322865,1164363,4994489,7320876,4031038,-2036888,5034601,-9098927,-9056762,-9827598,-2762269,-7689012,7127061,4020330,6512128,-1156246,3571495,5388307,-4969113,2118509,5411790,-9655083,-572819,-4186494,7775941,478500,-8289896,3328444,4329332,4091188,-5611161,-2027703,4289457,-7329518,-9739740,6560991,9112308,2164824,-8818714,7239204,-5603429,-5659909,-8668315,-1874581,-5978467,5705017,651321,747667,7180173,8158904,-6695904,9732873,4714316,1865646,-1738344,-442627,8001906,366162,7747907,1328022,3241603,7556153,9977970,4545917,433814,5136053,6971048,-1483172,9258771,-2769108,2495273,3170658,-7277004,-2903161,-5104774,-5831707,-9250574,-4276957,664375,-8734748,-3773330,-5538367,4637853,-932667,6308513,-3599717,-3201277,-1702967,-4275762,-9321013,2276903,-7321002,-7787434,1793680,-2797948,-1421363,1819511,4398558,6193158,-9003006,5047133,7630486,1308811,-3001765,-6857856,8649103,2216541,724938,-5524269,-1623261,8654301,-6057258,5861629,-5032170,-6895815,-1003619,-2450585,2544057,6390889,4655893,194459,-2940491,-9399918,-2225728,6667900,6731612,-2019387,-410708,7226727,-6954899,5162041,4600893,-9684418,7979363,3272380,2640858,-3424552,-9430055,-4546570,-3273081,-1684766,9237395,-6489178,1425283,-2230845,351271,-4355198,-2924300,877195,-13620,-5765150,4715114,7839148,8982768,2223961,9345644,-3263152,7617224,6533515,2881695,5836797,-7156020,-2440178,2364641,-6990073,8994440,5422913,-7575952,-2922731,5926480,-7758037,3850264,1040662,-6126638,4972693,7217650};
        int target = -3483173;
        int len = nums.length;

        int[] ints = Arrays.copyOfRange(nums, 0, len);
        // 비트 마스크로 모든 경우의 수 탐색
        //1 << 31은 int 범위를 초과하게 되어 올바르게 동작하지 않습니다.
        for (int bit = 0; bit < (1 << len); bit++) {
            if (Integer.bitCount(bit) == 2) { // 2개의 숫자 선택
                int sum = 0;
                int[] selectedIndices = new int[2];
                int index = 0;
                for (int i = 0; i < len; i++) {
                    if ((bit & (1 << i)) != 0) {
                        sum += nums[i];
                        if (index < 2) { // 배열 범위를 초과하지 않도록 확인
                            selectedIndices[index++] = i;
                        }else{
                            break;
                        }
                    }
                }
                if (sum == target) {
                    System.out.println(selectedIndices[0] + " " + selectedIndices[1]);
                }
            }
        }
    }
}
~~~

## 방식 :https://shorturl.at/Zyqwk

* 최대 nums의 개수가 3만 미만인데, 구성 value 숫자를 크게 해서 함정을 판 건가? 그래서 index로 연산 필수같다.
* 중복을 제거한 배열의 length가 정답

### 2칸짜리 포인터로 찐 정렬

~~~java
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length <= 2) {
            return nums.length;
        }

        int index = 2;

        for (int i = 2; i < nums.length; i++) {
            if (nums[i] != nums[index - 2]) {
                nums[index] = nums[i];
                index++;
            }
        }
        return index;
    }

}
~~~


### 개수만 세서 후다닥 지나가기

~~~java
class Solution {
        public int removeDuplicates(int[] nums) {
        if (nums.length <= 2) {
            return nums.length;
        }

        int count = 1; // 현재 원소의 개수
        int length = 1; // 최종 결과 배열의 길이(문제에 최소 nums길이 1)

        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == nums[i - 1]) {
                count++; // 현재 원소가 이전 원소와 같으면 개수 증가
            } else {
                count = 1; // 현재 원소가 이전 원소와 다르면 개수 초기화
            }
            if (count <= 2) { // 현재 원소의 개수가 2 이하이면 길이 증가
                nums[length] = nums[i]; // 배열 수정 (결과 배열의 길이를 유지하기 위함)
                length++;
            }
        }

        return length; // 중복을 제거한 후의 길이 반환
    }
}
~~~
