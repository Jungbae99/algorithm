### 문제 번역

정수 배열 `nums`가 오름차순으로 정렬되어 있다고 가정합니다. 각 고유한 요소가 최대 두 번 나타나도록 제자리에서 일부 중복을 제거하세요. 요소들의 상대적 순서는 동일하게 유지해야 합니다.

일부 언어에서는 배열의 길이를 변경하는 것이 불가능하기 때문에, 결과는 대신 `nums` 배열의 첫 번째 부분에 배치되어야 합니다. 더 구체적으로 말하면, 중복을 제거한 후 `k` 개의 요소가 남아 있다면, `nums`의 첫 번째 `k` 요소가 최종 결과를 가져야 합니다. 첫 번째 `k` 요소 이외의 값들은 신경 쓰지 않아도 됩니다.

최종 결과를 `nums`의 첫 `k` 슬롯에 배치한 후 `k`를 반환하세요.

다른 배열을 위해 추가 공간을 할당하지 마세요. O(1) 추가 메모리로 입력 배열을 제자리에서 수정해야 합니다.

**Custom judge:**

다음 코드를 사용하여 솔루션을 테스트할 것입니다:

``` java
int[] nums = [...]; // 입력 배열
int[] expectedNums = [...]; // 올바른 길이로 기대되는 답안

int k = removeDuplicates(nums); // 구현한 메서드 호출

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

모든 코드를 만족하면, 솔루션은 통과됩니다.

예제 1:

``` text
입력: nums = [1,1,1,2,2,3]
출력: 5, nums = [1,1,2,2,3,_]
설명: 함수는 k = 5를 반환해야 하며, nums의 첫 다섯 요소는 각각 1, 1, 2, 2, 3이어야 합니다. 첫 다섯 요소 이외의 값은 중요하지 않습니다 (따라서 언더스코어로 표시).
```

예제 2:

``` text
입력: nums = [0,0,1,1,1,1,2,3,3]
출력: 7, nums = [0,0,1,1,2,3,3,_,_]
설명: 함수는 k = 7을 반환해야 하며, nums의 첫 일곱 요소는 각각 0, 0, 1, 1, 2, 3, 3이어야 합니다. 첫 일곱 요소 이외의 값은 중요하지 않습니다 (따라서 언더스코어로 표시).
```

제약 사항:

- `1 <= nums.length <= 3 * 10^4`
- `10^4 <= nums[i] <= 10^4`
- `nums`는 오름차순으로 정렬되어 있습니다.

---

### 문제 분석

- 정렬 되어 있는 숫자 배열을 입력으로 준다.
    - 어? 그럼 맨 처음 숫자는 연산에서 제외해도 되겠다.
- 출력은 중복이 최대 2개 까지만 허용된 배열의 사이즈 출력이다.

### 접근 방법

- 문제 힌트에 나와있듯이 포인터 사용?
    - 비교적 코드가 짧을 것으로 예상되는 것으로 선택!
- 아님 각 요소의 빈도를 세는 카운터 사용?

### 코드

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length <= 2) {
            return nums.length;
        }

        int j = 1;
        for (int i = 2; i < nums.length; i++) {
            if (nums[i] != nums[j - 1]) {
                nums[++j] = nums[i];
            }
        }
        return j + 1;
    }
}
```

### 디버그 표

| Iteration | i | j | nums[i] | nums[j-1] | nums 상태 | 설명 |
| --- | --- | --- | --- | --- | --- | --- |
| 초기 상태 | - | 1 | - | - | [1, 1, 1, 2, 2, 3] | 초기 상태 |
| 1 | 2 | 1 | 1 | 1 | [1, 1, 1, 2, 2, 3] | nums[i] == nums[j-1] |
| 2 | 3 | 2 | 2 | 1 | [1, 1, 2, 2, 2, 3] | nums[i] != nums[j-1], j 증가 후 nums[j] 갱신 |
| 3 | 4 | 3 | 2 | 1 | [1, 1, 2, 2, 2, 3] | nums[i] != nums[j-1], j 증가 후 nums[j] 갱신 |
| 4 | 5 | 4 | 3 | 2 | [1, 1, 2, 2, 3, 3] | nums[i] != nums[j-1], j 증가 후 nums[j] 갱신 |
| 종료 | - | 4 | - | - | [1, 1, 2, 2, 3, 3] | 루프 종료, j + 1 반환 |

따라서, 5가 반환됨
