## 13번 팰린드롬 연결 리스트

~~~java
class Main {
    public static void main(String[] args) throws Exception {

    }

    public static boolean isPalindrome(ListNode head) {
        ListNode fast = head, slow = head;
        //1
        while (홀수개끝도달했는지체크(fast) && 짝수개끝도달했는지체크(fast)){
            fast = fast.next.next;
            slow = slow.next;
        }

        //2
        홀수개인경우_slow_한칸더전진(fast, slow);


        //3 이제부터 fast는 필요 없다.
        // slow로 역순 노드를 만들기 위해 필요한 부분을 추출하기 위한 페이스메이커용이었기 때문

        ListNode tail = null;
        slow를_reverse_시키는_tail_노드리스트만들기(slow, tail);
        
        while(tail != null){
            if(head.val != tail.val){
                return false;
            }
            head = head.next;
            tail = tail.next;
        }
        
        return true;
    }

    /**
     * slow에 비교하기 위한 시작지점을 저장해놨기 때문에,
     * 한 칸씩 오른쪽으로 이동하면서 역순리스트를 만들어서 tail 연결리스트를 구현해낸다.
     * \ ㅇ ㅇ ㅇ \ ㅇ  / ㅇ ㅇ ㅇ / <- 이부분을 잘라서  역순으로 전환
     *                slow
     * @param slow
     * @param tail
     */
    private static void slow를_reverse_시키는_tail_노드리스트만들기(ListNode slow, ListNode tail) {
        while(slow != null){
            ListNode temp = slow.next; // 맨 앞을 제외한 노드들 임시 저장
            slow.next = tail; // 맨 앞 노드를 tail에 붙인다.
            tail = slow; // slow에 붙였기 때문에 tail을 slow 로 치환
            slow = temp; //slow는 계속해서 잘라서 써야하기 때문에 temp로 치환
            /**
             * slow에서 맨 앞 노드 하나씩 꺼내서 tail의 왼쪽에 붙여나가는 방식으로 역순으로 만들어낸다.
             * 
             *  역순 변환 예시
             *  > 초기 상태
             *  slow = 1 -> 2 -> 3
             *  tail null
             *
             *  > 1회차
             *  slow = 2 -> 3
             *  tail = 1 -> null
             *  
             *  > 2회차
             *  slow = 3
             *  tail = 2 -> 1 -> null
             *  
             *  > 3회차
             *  slow = null
             *  tail = 3 -> 2 -> 1 -> null
             *
             *
             *
             */
        }
    }

    /**
     * 팰린드롬 노드가 홀수개인 경우 slow 한칸 더 전진시킨다.
     * 역순 노드 리스트를 만들어서 head는 시작부터,
     * slow로 만든 reverse노드는 끝에서부터 양 끝끼리 비교하며 들어오려는 목적이다.
     * ㅇ   ㅇ   ㅇ   ㅇ   ㅇ
     *        slow  ->
     *
     * ㅇ  ㅇ  ㅇ | ㅇ  ㅇ |  <-  이부분을 잘라서  역순으로 전환하는데 중앙 노드는 비교할 필요가 없다.
     * @param fast
     * @param slow
     */

    private static void 홀수개인경우_slow_한칸더전진(ListNode fast, ListNode slow) {
        if(홀수개끝도달했는지체크(fast)){
            slow = slow.next;
        }
    }

    /**
     * checkIfOdd 팰린드롬 노드가 홀수개인 경우 체크
     * 홀수개인 경우 2칸씩 전진하면 끝에 도달해 fast.next == null 이 된다.
     *    ㅇ    ㅇ    ㅇ
     * start   ->    ->
     * @param temp
     * @return
     */
    public static boolean 홀수개끝도달했는지체크(ListNode temp){
        return temp != null;
    }

    /**
     * checkIfEven 팰린드롬 노드가 짝수개인 경우 체크
     * 짝수개인 경우 2칸씩 전진하면 끝에 도달해 fast == null 이 된다.
     *     ㅇ    ㅇ    ㅇ    ㅇ   null
     *  start   ->    ->
     *                     ->   ->
     * @param temp
     * @return
     */
    public static boolean 짝수개끝도달했는지체크(ListNode temp){
        return temp.next != null;
    }

    private static class ListNode {
        int val;
        ListNode next;

        ListNode() {
        }

        ListNode(int val) {
            this.val = val;
        }

        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }
}
~~~


## 이중 연결 LinkedList

~~~java
import java.util.HashMap;

class LRUCache {
    private class Node {
        int key, value;
        Node prev, next;
        Node(int k, int v) {
            key = k;
            value = v;
        }
    }

    private int capacity, size;
    private Node head, tail;
    private HashMap<Integer, Node> cache;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        cache = new HashMap<>();
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) return -1;
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        Node node = cache.get(key);
        if (node == null) {
            Node newNode = new Node(key, value);
            cache.put(key, newNode);
            addNode(newNode);
            size++;
            if (size > capacity) {
                Node tail = popTail();
                cache.remove(tail.key);
                size--;
            }
        } else {
            node.value = value;
            moveToHead(node);
        }
    }

    private void addNode(Node node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    private void removeNode(Node node) {
        Node prev = node.prev;
        Node next = node.next;
        prev.next = next;
        next.prev = prev;
    }

    private void moveToHead(Node node) {
        removeNode(node);
        addNode(node);
    }

    private Node popTail() {
        Node res = tail.prev;
        removeNode(res);
        return res;
    }
}
~~~


## Deque

~~~java
import java.util.Deque;
import java.util.HashMap;
import java.util.LinkedList;

class LRUCache {
    private final int capacity;
    private final HashMap<Integer, Integer> cache;
    private final Deque<Integer> deque;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap<>();
        this.deque = new LinkedList<>();
    }

    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }
        deque.remove(key);
        deque.addFirst(key);
        return cache.get(key);
    }

    public void put(int key, int value) {
        if (cache.containsKey(key)) {
            cache.put(key, value);
            deque.remove(key);
            deque.addFirst(key);
        } else {
            if (cache.size() >= capacity) {
                int leastUsedKey = deque.removeLast();
                cache.remove(leastUsedKey);
            }
            cache.put(key, value);
            deque.addFirst(key);
        }
    }
}

~~~
