
```java

class Main{
    public static int arrayPairSum(int[] nums) {
        // [case_1] 6,2,6,5,1,2
        // 2개씩 짝 지었을때 각 짝의 최솟값들의 합이 최댓값이 되는 경우 최댓값을 return 하라.
        // 여기까지 읽으면... 각 짝의 최솟값이 커야 합도 커질거야. 라고 생각할 수 있습니다.

        // 각 짝의 최솟값이 크려면? 작은 수들은 최대한 작은 수들끼리 모으고, 큰 수는 큰 수끼리 모아야 합니다.
        // 왜냐? (6,1) 예를 들어 이렇게 짝지어버리면 최솟값은 1이고, (2,1)이렇게 짝지어도 최솟값은 1이에요 즉, 큰 수를 최대한 낭비하지 않는게 관건이죠
        // 그렇기 때문에 두 수의 차이가 작아야 큰 수를 낭비하지 않을 수 있어.

        // 해법 : 작은수들끼리 먼저 오름차순으로 정렬한다음 최대한 짝을 지어주자
        // (1,2), (2,5), (6,6) -> 1 + 2 + 6
        // [case_2] 1,4,3,2 가 주어지면? (1,2), (3,4) -> 1 + 3 = 4

        Arrays.sort(nums);
        // [case_1] 1,2,2,5,6,6

        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            // 홀수일때 더해주면 됩니다. 1 + 2 + 6
            if (i % 2 == 0) {
                sum += nums[i];
            }
        }
        return sum;
    }
}
```

// 2번째 문제는 모르겠어서 답지를 봤고
// 3번째 문제는 bruteforce 를 이용해 O(n^2)로 풀었으며 책의 풀이과 같아서 정리하지 않았습니다.

